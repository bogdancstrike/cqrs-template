# **ADR 005: Use of Apache Kafka for Event Input and Inter-Component Communication**

## **Status**

Accepted

## **Context**

The Alert Management System needs to ingest alert-generating messages from external sources. These messages trigger the creation of alerts within the system. Furthermore, in a CQRS architecture, events generated by the command side need to be reliably propagated to the query side (projectors) and potentially other interested consumers. A robust, scalable, and asynchronous messaging system is required for these purposes.

## **Decision**

We will use **Apache Kafka** for the following roles:

1. **Alert Input Bus:** External systems will publish messages (potential alerts) to a designated Kafka topic. A Kafka consumer within the Alert Management System will process these messages and translate them into commands (e.g., CreateAlertCommand).  
2. **Event Bus for Axon Framework (Optional but Recommended for Decoupling):** While Axon can use its internal event bus or other mechanisms like Spring Cloud Bus, using Kafka as the transport for events published by Axon aggregates provides better decoupling between the command and query sides, especially in a distributed environment. This allows event processors (projectors) to consume events from Kafka topics.

## **Consequences**

### **Positive:**

* **Decoupling:**  
  * **Input Decoupling:** Producers of alert messages are decoupled from the Alert Management System's command processing logic. The system can evolve independently of how messages are produced.  
  * **Component Decoupling (if used for Axon events):** The command side (producing Axon events) is decoupled from the query side (consuming Axon events). They can be deployed and scaled independently.  
* **Scalability:** Kafka is designed for high throughput and horizontal scalability. It can handle large volumes of incoming messages and distribute events efficiently.  
* **Durability and Reliability:** Kafka provides message persistence and replication, ensuring that messages and events are not lost even if consumers are temporarily unavailable.  
* **Resilience:** Consumers can process messages at their own pace. If a consumer fails, it can resume processing from its last committed offset once it recovers.  
* **Stream Processing Capabilities:** Kafka's stream-oriented nature allows for potential future integration with stream processing frameworks (e.g., Kafka Streams, Flink) for complex event processing or real-time analytics on the input stream or event stream.  
* **Backpressure Handling:** Kafka naturally handles backpressure, as producers can publish messages without waiting for consumers to be ready.  
* **Standardization:** Kafka is a widely adopted industry standard for messaging and event streaming.  
* **Axon Kafka Extension:** Axon Framework provides an extension (axon-kafka) that simplifies publishing and consuming Axon events via Kafka, integrating with Axon's event processors.  
* **Testcontainers Support:** Kafka is well-supported by Testcontainers, facilitating reliable integration testing.

### **Negative:**

* **Operational Overhead:** Managing a Kafka cluster (brokers, Zookeeper/KRaft) adds operational complexity and requires expertise.  
* **Increased Latency (Minor):** Introducing a message broker adds a hop, which can introduce minor latency compared to direct in-process communication. However, for asynchronous processing, this is usually acceptable and offset by the benefits of decoupling and resilience.  
* **Complexity:** Setting up and configuring Kafka producers and consumers, managing topics, partitions, and consumer groups adds to the overall system complexity.  
* **Exactly-Once Semantics:** Achieving true exactly-once semantics for message processing can be complex and requires careful configuration on both Kafka and the consumer side. Axon's Kafka extension helps with this for event publishing. For input messages, idempotency in command handlers might be needed.  
* **Message Ordering:** Kafka guarantees message ordering within a partition. If global ordering is required across partitions (rarely needed for this type of system), it becomes more complex. For Axon events, ordering per aggregate ID is typically sufficient and handled by routing events for the same aggregate to the same partition.

## **Alternatives Considered**

1. **Synchronous API Calls for Input:** Exposing a REST API for external systems to directly submit alert creation requests.  
   * Pros: Simpler for producers if they prefer synchronous communication.  
   * Cons: Tightly couples producers to the availability and performance of the Alert Management System. Less resilient to temporary outages or load spikes. Does not provide the same level of buffering and decoupling as Kafka.  
2. **Other Message Brokers (e.g., RabbitMQ, ActiveMQ):**  
   * Pros: Mature, offer different messaging patterns (e.g., RabbitMQ's flexible routing).  
   * Cons: While capable, Kafka is generally favored for high-throughput, log-based streaming scenarios and large-scale event distribution. For event sourcing style events, Kafka's log paradigm is a natural fit. Axon's Kafka extension is also a strong plus.  
3. **Axon Server as Event Bus:** If using Axon Server for the event store, it also acts as an event bus.  
   * Pros: Integrated solution with Axon Server.  
   * Cons: Ties event distribution to Axon Server. Using Kafka provides a more general-purpose event backbone that can be used by non-Axon components as well and offers greater flexibility if Axon Server is not used for the event store (as decided in ADR-003).  
4. **Direct In-Process Eventing (for Axon events):** Using Axon's default in-memory event bus.  
   * Pros: Simplest for a monolithic deployment.  
   * Cons: Tightly couples command and query sides within the same process. Does not support distributed deployments or independent scaling of components.

## **Justification**

Apache Kafka is the most suitable choice for both the alert input bus and as a robust transport for Axon events between the command and query sides. Its strengths in scalability, durability, decoupling, and resilience are critical for a production-grade Alert Management System. The ability to handle high-volume input and reliably distribute events for read model projections makes it a cornerstone of the architecture. The availability of the Axon Kafka extension simplifies its integration for distributing domain events. The operational overhead is a recognized trade-off for these substantial benefits.