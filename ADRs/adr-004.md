# **ADR 004: Choice of Elasticsearch for the Read Model**

## **Status**

Accepted

## **Context**

The Alert Management System requires a flexible and performant read model to serve various query needs. Users need to search alerts by keywords, filter by timestamp ranges, query by status, and retrieve sorted lists of alerts. The read model must be updated based on events generated by the command side and should be optimized for these query patterns.

A traditional relational database could be used for the read model, but for advanced search capabilities (like full-text search) and potentially large volumes of alert data, a specialized search engine might be more appropriate.

## **Decision**

We will use **Elasticsearch** as the persistence and query engine for the read model(s) of the Alert Management System. Alert data will be projected into Elasticsearch indices, denormalized for optimal query performance.

## **Consequences**

### **Positive:**

* **Powerful Search Capabilities:** Elasticsearch excels at full-text search, complex filtering, aggregations, and relevance scoring. This is ideal for querying alerts by keywords or other free-form criteria.  
* **Scalability and Performance:** Elasticsearch is designed to scale horizontally and can handle large volumes of data and high query loads efficiently.  
* **Flexible Data Model:** Elasticsearch's document-oriented nature allows for flexible, denormalized data structures, which are optimal for read models. Schema changes can often be less disruptive than in RDBMS.  
* **Real-time (Near Real-time) Indexing:** Elasticsearch can index data quickly, making new or updated alerts available for querying with low latency (near real-time).  
* **Rich Query DSL:** Provides a comprehensive JSON-based Query DSL for constructing sophisticated queries.  
* **Integration with Spring Data:** spring-data-elasticsearch simplifies integration, providing familiar repository patterns and abstractions.  
* **Ecosystem and Tooling:** Elasticsearch has a rich ecosystem, including tools like Kibana for visualization and exploration, which can be beneficial for analyzing alert data.  
* **Support for Geospatial Queries and Aggregations:** While not an initial requirement, Elasticsearch's support for these could be valuable for future enhancements if alerts have location data.  
* **Testcontainers Support:** Elasticsearch is well-supported by Testcontainers, enabling reliable integration testing of the query side.

### **Negative:**

* **Operational Complexity:** Managing an Elasticsearch cluster can be more complex than a single relational database instance, especially at scale. This includes considerations for sharding, replication, and backups.  
* **Eventual Consistency:** As with any CQRS read model updated asynchronously, data in Elasticsearch will be eventually consistent with the write model. The delay depends on the projection logic.  
* **Not a Primary Datastore for Relational Data:** Elasticsearch is not a relational database and lacks features like ACID transactions across multiple documents or joins in the traditional SQL sense. This is acceptable as it's used for a denormalized read model, not as the system of record.  
* **Resource Intensive:** Elasticsearch can be resource-intensive (CPU, memory, disk I/O), especially for large indices and high indexing/query rates.  
* **Learning Curve:** Developers may need to learn Elasticsearch concepts, its Query DSL, and best practices for indexing and querying.

## **Alternatives Considered**

1. **PostgreSQL for Read Model:** Using the same PostgreSQL database (or a separate instance/schema) for the read model.  
   * Pros: Simpler infrastructure if already using PostgreSQL for the event store, strong consistency if in the same transaction (though not typical for CQRS projectors), mature SQL querying.  
   * Cons: Full-text search capabilities are less advanced than Elasticsearch (though PostgreSQL has improved significantly). May not scale as well for very high query loads or large denormalized datasets compared to a dedicated search engine. Optimizing for both OLTP (event store) and OLAP-like queries (read model) on the same instance can be challenging.  
2. **Other NoSQL Databases (e.g., MongoDB, Cassandra):**  
   * Pros: Scalability, flexible schemas.  
   * Cons: May lack the specialized full-text search and aggregation capabilities of Elasticsearch. Each has its own operational characteristics and learning curve.  
3. **In-Memory Cache (e.g., Redis, Hazelcast) with RDBMS:** Using an RDBMS as the source of truth for the read model and an in-memory cache for performance.  
   * Pros: Can provide very fast reads for frequently accessed data.  
   * Cons: Adds complexity of cache invalidation/synchronization. Search capabilities are limited by the cache or underlying RDBMS. Not ideal for complex ad-hoc queries or large datasets that don't fit in memory.

## **Justification**

Elasticsearch's superior search and aggregation capabilities, scalability, and suitability for denormalized document-based read models make it the best choice for the Alert Management System's query side. The requirements for keyword searching, filtering by various criteria, and handling potentially large volumes of alert data align well with Elasticsearch's strengths. The integration with Spring Data Elasticsearch and support from Testcontainers further solidify this choice. The trade-off of eventual consistency is acceptable, and the operational overhead is manageable for the expected benefits.